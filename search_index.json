[
["index.html", "Liverpool Compton Imaging App Overview", " Liverpool Compton Imaging App Overview Adam Caffrey 2020-01-28 "],
["01-about.html", "1 About this App", " 1 About this App The Compton imaging app is designed to streamline the process of visualising and analysing data from MTsort. It is written in the R coding language and uses the shiny library, a package to build interactive web applications. The code has been compiled into a stand-alone application using a process developed by Columbus Collabatory. This was described in the 2018 R Consortium conference and is available to watch on Youtube. A Github repository exists with the basic elements required to design your own stand-alone app. Slight alterations were required to include particular functionality needed for Compton imaging which shall be discussed in a later section. The Compton imaging app was built by myself, Dr. Adam Caffrey, and incorporated algorithms written by Dr. Dan Judson. Please ensure this is reflected in the references of any future publications. The current version as of writing this document is 3.0.2 and was compiled on Mac OS Catalina. If you have any questions or require help fixing the app please contact me at adam.d.caffrey@gmail.com. This document is designed for anyone wishing to develop the application further, or those who are struggling to understand how to use it. "],
["02-userGuide.html", "2 User Guide", " 2 User Guide This section will overview how to use the app in the context of a software user. This guide is accurate as of version 3.0.1. "],
["03-userLoadData.html", "2.1 Loading Data into the Application", " 2.1 Loading Data into the Application Upon loading the application you will see a screen similar to the image below. You are prompted to select a GEANT4 formatted file. This style is based on the input format of Dan’s analytical reconstruction code, originally written in C. Data can be separated by either a tab, comma or equal amounts of whitespace. The data must have 8 or more columns. The data format should be as follows: Z1 Y1 X1 E1 Z2 Y2 X2 E2 Tier 67 16.5 -4.4 22 0 27.5 -10.5 424 0 67 8.8 5.5 62 4 6.5 -27.5 314 0 67 9.9 23.1 35 16 0.5 11.5 628 0 67 -22.0 -2.2 94 15 -11.5 0.5 175 1 67 -14.3 -27.5 46 14 11.5 23.5 182 0 67 -2.2 7.7 59 6 1.5 22.5 145 0 67 -2.2 -24.2 37 15 -16.5 0.5 164 0 67 -8.8 1.1 39 1 13.5 -9.5 161 0 67 -8.8 -8.8 170 14 27.5 -27.5 123 0 67 27.5 5.5 37 7 10.5 -2.5 230 1 If only 8 columns of data are supplied the Tier column will be absent. If more than 8 columns are supplied only 9 will be loaded and the remaining will be cropped. The ninth column will hold the Tier flag. The tier flag looks for any two numeric values. 0 and 1 are typically output from MTsort but any two values can be used. The input data should contain no column names. Names are asigned upon being loaded into the program and depend on the number of input columns. A portion of the input information will be diplayed as a table. This table should be used to explore the data. It can tell you the range of values, number of entries and can highlight any obvious outliers. "],
["04-userEnergySpectra.html", "2.2 Displaying Energy Spectra", " 2.2 Displaying Energy Spectra An energy spectrum will be plotted upon openning the Energy Spectrum tab, the requirement for this is that a file has been sucessfully loaded into the application. The default energy range displayed is 0-1500 keV, this was chosen to ensure a full Eu-152 energy spectrum could be displayed without further actions. The maximum limit of this range has been set to 8 MeV for ongoing Y-88 work. Placing the mouse over the spectrum will indicate the energy at that position. This can be used, along with the range limits, to determine precise photopeak positions. Under the additional setting tab you can change the colour of the spectrum. The allowed inputs for this field can be found here. Hex input is also accepted (#01ee32). You can change the y-scale from normal to log mode, and finally you can display subsets of data. This options for subsetting the data only appear if the data contains a Tier column. You can choose to display: 2-tier data only 3-tier data only Both datasets displayed individually Both datasets combined and displayed To select one of these options you have to double-click the corresponding button. "],
["05-userEnergyMatrix.html", "2.3 Energy Matrix", " 2.3 Energy Matrix This tab dislpays the energy deposited in the scatter detector (x-axis) against the energy deposited in the absorber detector (y-axis). Diagonal lines indicate photopeaks in the energy spectrum and horizontal/vertical lines can be an indication of several unwanted phenomena. A colour scheme for the 2D plot can be selected from the top drop-down menu. To apply the choice, you must click the “Render Plot” button at the bottom of the options pane. Clicking once anywhere on the plotting region will display the energy deposited in each detector at that point, along with the summed energy. This can be useful for identifying specific photopeaks. There are two methods to zoom into a region. First, you can use the sliders and once satisfied click the “Render Plot” button. Alternatively, you can drag a rectange across the region of interest and then double click on the highlighted shape. Either method is valid but to return functonality to the “Render Plot” button after using the second method, you must first double click on the plot without dragging a rectangle. "],
["06-userDetectorHits.html", "2.4 Detector Hits", " 2.4 Detector Hits This tab displays the X-Y hit locations from the input file for each detector. The number of events displayed can be selected from the slider at the bottom of the screen. These events are randomly sampled up to a maximum value of 10,000. This upper limit was chosen to reduce processing times. In the setting tab you can change the colour of the points and the outline of the front detector in case you are using SmartPET insead of GRI+. The standard set-up displays regions of more counts as larger and more opaque. This plotting style can also be altered on the settings tab where the opacity and alternative sizing of points can be disabled. If the data was loaded incorrectly due to a mix up in the coordinate system, this can be fixed without returning to MTsort by playing with the “Flip” and “Switch” buttons. "],
["07-userDepthAbs.html", "2.5 Depths of Interactions", " 2.5 Depths of Interactions This tab will display a histogram of the interaction positions within the absorber detector. You can use this information in combination with the previous tab to determine which form of PSA was applied to the data. As with the previous tab, the number of events displayed can be selected from the slider at the bottom of the screen. These events are randomly sampled up to a maximum value of 100,000. This upper limit was chosen to reduce processing times. The settings tab allows you to change the colour of the histogram bars and add labels to show the number of counts in each. Gates can be applied to the energy deposited in the absorber detector to filter particuar events. This is useful if you wish to see the attenuation profile in the distribution. "],
["08-userImageReconstruction.html", "2.6 Reconstructing Data", " 2.6 Reconstructing Data On this tab you can feed the input data to one of the available image reconstruction codes. Currently only the analytical and SOE codes can be selected and their workings are described in the Instructions section of the app. The various options which can be set are: Image space size: This is the size of the 2D slice which cones are projected onto. It must be a factor of 200 and the field can be manually typed into or you can hit the arrow keys on your keyboard to jump between allowed values. Distance of source: Distance of the source from the front of the scatter detector cryostat in centimeters. Cryostat separation: Inner distance between the scatter and absorber cryostats in millimeters. Points per degree: Degree of conic sampling. The projected cones cannot be continuous surfaces and so they are discretised into a set number of rays per angular degree of each cone. Image space compression: Size of the pixels on the slice. A larger value will produce a clearer image with less data. Number of iterations: This option becomes available if you opt to use the SOE code. It sets the number of iterations to be run. Averaging grid size: The size of the 2D density grid used by the SOE code. Its function is described in the app’s Instructions section. Nuber of events to run: If you select “Run set number of events” then the total number of events in the file will be displayed in a text input field. This value can then be altered to however many events you wish to run. The value indicates the number of events which shall be run after energy gates have been applied. An additional option will appear asking whether the events selected should be randomly sampled from the dataset or sequential. Tiers to reconstruct: Allows you to reconstruct events which interacted in 2-tiers, 3-tiers or both. This option is only available if a 9th column exists in the data. Energy gates should be set from the Energy Gates tab before reconstruction and should reflect photopeak positions. The Energy Spectrum tab can be used to precisely find these values. Up to 5 energy gates can be set as of version 3.0.2. You can also select whether or not the data should be saved. If it is to be saved then please remember to set the save directory from the Settings tab before reconstructing the data. The 2D slice from each iteration of the reconstruction codes will be saved as a vector. This file can then be loaded into the image reconstruction pane at a future time if you don’t want to wait for the reconstruction again. You can also opt to produce a 3D plot from the data. I have included this as a separate option as the time it takes is fairly lengthy and it doesn’t provide much insight. "],
["09-userFitting.html", "2.7 Fitting Data", " 2.7 Fitting Data Once data has been reconstructed from the Image Reconstruction page, this page can be used to fit a distribution to the data and view the Compton image. The page is split into 4 main sections: Section 1 - Displaying the Filled Contour Plot The 2D Compton slice is viewed by hitting the “Remake Contour Plot” button. Before creation you can select: Whether you want to display contour lines on top of this image. If you want to see a vertical/horizontal line at the row/column of the corresponding image profile. The colour scheme for the plot. Section 2 - FWHM Plot Controls This pane primarlily focusses on creating the intensity profile from the Compton image. You can choose to view a profile through the pixel of maximum intensity or manually select a row/column in the image. A “Remake Contour Plot” button also exists on this page to quickly display the image with the row/column representing the profile highlighted. Click the “Remake FWHM Plot” button to display the intensity profile. If the image consists of a single point source then a fit shall be attemped, otherwise a simple black line shall represent the data. The created profile can be saved to the directory chosen from the “Settings” page using the button at the far right. This data cannot be reloaded back into the app but will contain all the necessary information to refit the profile in another language if you wish. Section 3 - Manual Fitting If the data consists of 2 point sources, or if a distribution representing a single point source could not be fitted, then a manual fit can be attempted on this tab. When you fit a single point source profile, the information used to fit the distribution will be automatically input into the first set of fit parameters on the left of the tab. Once you are happy with the settings click “Refit Data” to attemp a manual fit. It is not always possible to fit the data using the app. In which case, I recommend saving the profile and writing a fitting algorithm in Matlab or python. Section 4 - Fit Statistics This tab will display the output of the fit (if acheived) and basic information on the image profile. The rightmost panel will display the equation used to fit the data and statistics which are useful to understand the quality of the fit. The information is better explained here. This information will also be saved using the “Save FWHM Slice” button from the second tab. This section should be used to note the FWHM of the distribution along with the total number of counts ran and maximum height of the profile. "],
["10-userFiltering.html", "2.8 Filtering Compton Images", " 2.8 Filtering Compton Images Once a Compton slice has been produced, a filter can be applied to reduce the high or low-frequency components. This can be especially useful to remove blur from an image and acheive a better output without the use of iterative reconstruction codes. Three filters are currently availble as of version 3.0.2; a high-pass filter, a low pass filter and a butterworth filter. Generally you will want to use a high-pass filter and the cutoff radius should be between 10 and 30. If data has been reconstructed then the Unfiltered Slice tab should fill automatically. Click “Filter Slice” to display the filtered slice in its corresponding tab. The profiles from the filtered and unfiltered slices can be displayed once you have chosen which row/column to display from the Profile Settings tab. The selection method is exactely as it was in the Image Reconstruction tab. The applied filter will be displayed in the Filter tab once it has been applied. More information on exactly what this shows can be found in the Instructions section of the app. Once you are satisfied with the results you can click “Save Output” to return the filtered and non-filtered slices as vectors to be analysed in your preferred coding language. "],
["11-userMultipleReconstruction.html", "2.9 Reconstructing Multiple Slices", " 2.9 Reconstructing Multiple Slices This tab allows you to reconstruct multiple image slices between two distances from the detector using the analytical reconstruction code. The options are very similar to those from the Image Reconstruction tab. In addition to the previous options, you now get the choice to: Calculate FWHM: Determine the FWHM from the image profile through the reconstructed Compton image at both the row and column passing through the pixel of maximum intensity. This can be useful to determine the most likely position of the source. Save Each: Select whether or not each reconstructed Compton image should be saved as a text file to the directory selected from the Settings tab. An additional text file is also saved with information regarding the FWHM and maximum overlaps at each reconstructed distance. Once you have reconstructed the data between your chosen distances you can view the following plots: 3D Plot: This displays a 3D scatter plot of overlaps at each position surrounding the source. A cutoff is set to only display points greater than a particular fraction of the maximum number of Compton cone overlaps. This cutoff fraction is set in the Plotting tab. The plot can be rotated and its colour scheme changed from this tab too. Once you are happy with your settings click “Update Plot” to display the results. Max at Distance: This plot displays the maximum overlap value in a reconstructed Compton image at each millimeter distance. This plot can be used to estimate the likely position of a source. The estimated position is displayed as text below the plot once each distance slice has been reconstructed. FWHM Row/Col: These plots display the FWHM calculated from the fitted distributions at each slice. If a distribution could not be fitted then the corresponding points are left blank (NA). An angular version of these plots are also created if you prefer to see the FWHM output in degrees rather than millimeters. "],
["12-developerGuide.html", "3 Developer Guide", " 3 Developer Guide This section is intended for anyone wanting to edit or update the app. It will describe the basic code structure, compilation process and other things you may need to be aware of. A basic understanding of R shiny is required for this guide. I won’t be giving an overview of the R scripts, these have been heavily commented and should be fairly readable. If you have any questions, don’t hesitate to email me! "],
["13-developerStructure.html", "3.1 App File Structure", " 3.1 App File Structure The file structure of this app is relatively simple. It consists of: R code files: These can all be found in the R_code folder. The server functions are separated for convenience and placed in the server_actions folder. Markdown files containing the documentation are placed in the Rmd folder. R compiler files: All the necessary files for the stand-alone R compiler are placed in the R-Portable_Mac folder. This includes the custom Rcpp functions used to run the reconstruction codes (dan &amp; SOE). Electron files: The remaining collection of files; main.js, package.json, package-lock.json and the node modules folder come from the electron instance. The basic structure is highlighted below: electron-quick-start │ main.js │ package.json | package-lock.json │ └─── node_modules │ │ ... │ └─── R-Portable-Mac | | ... │ └─── R_code │ ui.R │ server.R | R_code.proj | └─── Rmd | | analytical.html | | citations.html | | filter.html | | Overview.html | | Release_Notes.html | | soe.html | └─── server_actions | energy_matrix.R | energy_spectrum.R | filtering.R | fitting.R | hit_locations.R | interaction_depths.R | load_data.R | multiple_slices.R | reconstructing.R The node_modeules and R-Portable-Mac folders contain too many files to comfortably display on the above file tree. The most important ones to note are the R shortcut and libraries folder in R-Portable-Mac and the electron folder in the node_modules folder. I have found this layout to be the optimum way to deal with multiple R scripts. Originally the ui.R and server.R were contained in the same file but this was too combersome. "],
["14-developerBasics.html", "3.2 Starting and Compiling the App", " 3.2 Starting and Compiling the App The application is based on a method devised by the Columbus Collabatory. Essentially, you call the shiny application from the stand-alone R compiler and display the webpage on a chromium browser. For now I only have it working on macbook, but it is possible to get it working on linux and windows too; I just haven’t had the time to do this yet. If you want to further develop/recompile the application you will need to install Node.js (a javascript runtime environment). This will allow you to use the javascript package manager, npm, from your terminal to install the “electron-packager” package globally (g argument). The electron-packager will be required to turn the code into an executable. Run the following when inside the electron-quick-start folder: npm install electron-packager -g The main.js and package.json files, along with the node_modules folder come standard when creating a new electron application. You will need to install the javascript dependencies too, listed in the node_modules folder: npm install To test if this worked you can run the app by typing the following: npm start The app will open up in a new chromium window after a brief loading screen. If you edit any of the R files, the changes can be seen immidiately if you hit npm start again. This is the way I recommend you debug any changes. To compile the app you need to type the following if you are on mac: npm run package-mac This will produce an additional folder called ElectronShinyAppMac. Within that is another folder, electron-quick-start-darwin-x64, which contains the executable. If you want to recompile the app, because you have altered the R code or whatever, then you can delete these new folders and run the command again. "],
["15-developerElectron.html", "3.3 Understanding the Electron Files", " 3.3 Understanding the Electron Files The two main electron files are package.json and main.js. You shouldn’t need to change these if you are editting the app but they are useful to understand and may need to be editted at a later date. The package-json.lock file is automatically created when you call npm install and keeps a record of the required javascript libraries and versions. package.json Firstly, the package.json file. The current contents as of 27-01-20 is displayed below. { &quot;name&quot;: &quot;electron-quick-start&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;A minimal Electron application&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;electron .&quot;, &quot;package-mac&quot;: &quot;electron-packager . --overwrite --platform=darwin --arch=x64 --out=ElectronShinyAppMac&quot;, &quot;package-linux&quot;: &quot;electron-packager . --overwrite --platform=linux --arch=x64 --icon=assets/icons/png/1024x1024.png --prune=true --out=release-builds&quot; }, &quot;repository&quot;: &quot;https://github.com/electron/electron-quick-start&quot;, &quot;keywords&quot;: [ &quot;Electron&quot;, &quot;quick&quot;, &quot;start&quot;, &quot;tutorial&quot;, &quot;demo&quot; ], &quot;author&quot;: &quot;GitHub&quot;, &quot;devDependencies&quot;: { &quot;electron&quot;: &quot;7.1.9&quot; } } This file displays details about the app, such as the name and version (I don’t really bother updating this because it is noted in the release notes). It is all relatively intuitive. The main lines to focus on are: &quot;main&quot;: &quot;main.js&quot;, This points to the file which is ran when the app is started. &quot;package-mac&quot;: &quot;electron-packager . --overwrite --platform=darwin --arch=x64 --out=ElectronShinyAppMac&quot;, &quot;package-linux&quot;: &quot;electron-packager . --overwrite --platform=linux --arch=x64 --icon=assets/icons/png/1024x1024.png These two lines are alias’ for compiling the code into an executable. It is what actually gets ran when you type npm run package-mac or package-linux. Packaging the app for linux isn’t something I’ve tried yet but it should be possible after a couple of changes to main.js. Similarly this could be done for windows too if you add the line: &quot;package-win&quot;: &quot;electron-packager . --overwrite --platform=win32 --arch=ia32 --icon=cc.ico --out=ElectronShinyAppWindows --version-string.CompanyName=ColumbusCollaboratory --version-string.FileDescription=CE --version-string.ProductName=\\&quot;Shiny Electron App\\&quot;&quot;, I’ve currently removed this line from the app because no-one seems to use windows in the University. I have kept most of the information in this file as it originally was. It can be changed if you like. main.js This is the file which is called when the app is run. I have printed the most important sections below as a reference for when I describe them later. const {app, BrowserWindow} = require(&#39;electron&#39;) const path = require(&#39;path&#39;) const url = require(&#39;url&#39;) const port = &quot;9194&quot; const child = require(&#39;child_process&#39;); const MACOS = &quot;darwin&quot; var killStr = &quot;&quot; var appPath = path.join(app.getAppPath(), &quot;R_code&quot;, &quot;ui.R&quot; ) var execPath = &quot;RScript&quot; if(process.platform == MACOS){ var macAbsolutePath = path.join(app.getAppPath(), &quot;R-Portable-Mac&quot;) var env_path = macAbsolutePath+((process.env.PATH)?&quot;:&quot;+process.env.PATH:&quot;&quot;); var env_libs_site = macAbsolutePath+&quot;/library&quot;+((process.env.R_LIBS_SITE)?&quot;:&quot;+process.env.R_LIBS_SITE:&quot;&quot;); process.env.PATH = env_path process.env.R_LIBS_SITE = env_libs_site process.env.NODE_R_HOME = macAbsolutePath execPath = path.join(app.getAppPath(), &quot;R-Portable-Mac&quot;, &quot;bin&quot;, &quot;R&quot; ) } else { throw new Error(&quot;This only works on mac, error!&quot;) } const childProcess = child.spawn(execPath, [&quot;-e&quot;, &quot;shiny::runApp(file.path(&#39;&quot;+appPath+&quot;&#39;), port=&quot;+port+&quot;)&quot;]) childProcess.stdout.on(&#39;data&#39;, (data) =&gt; { console.log(`stdout:${data}`) }) childProcess.stderr.on(&#39;data&#39;, (data) =&gt; { console.log(`stderr:${data}`) }) function createWindow () { let loading = new BrowserWindow({show: false, frame: false}) loading.loadURL(&quot;data:text/html;charset=utf-8;base64,PGh0bWw+DQo8c3R5bGU+DQpib2R5ew0KICBwYWRkaW5nOiAxZW07DQogIGNvbG9yOiAjNzc3Ow0KICB0ZXh0LWFsaWduOiBjZW50ZXI7DQogIGZvbnQtZmFtaWx5OiAiR2lsbCBzYW5zIiwgc2Fucy1zZXJpZjsNCiAgd2lkdGg6IDgwJTsNCiAgbWFyZ2luOiAwIGF1dG87DQp9DQpoMXsNCiAgbWFyZ2luOiAxZW0gMDsNCiAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZDsNCiAgcGFkZGluZy1ib3R0b206IDFlbTsNCiAgZm9udC13ZWlnaHQ6IGxpZ2h0ZXI7DQp9DQpwew0KICBmb250LXN0eWxlOiBpdGFsaWM7DQp9DQoubG9hZGVyew0KICBtYXJnaW46IDAgMCAyZW07DQogIGhlaWdodDogMTAwcHg7DQogIHdpZHRoOiAyMCU7DQogIHRleHQtYWxpZ246IGNlbnRlcjsNCiAgcGFkZGluZzogMWVtOw0KICBtYXJnaW46IDAgYXV0byAxZW07DQogIGRpc3BsYXk6IGlubGluZS1ibG9jazsNCiAgdmVydGljYWwtYWxpZ246IHRvcDsNCn0NCg0KLyoNCiAgU2V0IHRoZSBjb2xvciBvZiB0aGUgaWNvbg0KKi8NCnN2ZyBwYXRoLA0Kc3ZnIHJlY3R7DQogIGZpbGw6ICNGRjY3MDA7DQp9DQo8L3N0eWxlPg0KPGJvZHk+PCEtLSAzICAtLT4NCjxkaXYgY2xhc3M9ImxvYWRlciBsb2FkZXItLXN0eWxlMyIgdGl0bGU9IjIiPg0KICA8c3ZnIHZlcnNpb249IjEuMSIgaWQ9ImxvYWRlci0xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCiAgICAgd2lkdGg9IjgwcHgiIGhlaWdodD0iODBweCIgdmlld0JveD0iMCAwIDUwIDUwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MCA1MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KICA8cGF0aCBmaWxsPSIjMDAwIiBkPSJNNDMuOTM1LDI1LjE0NWMwLTEwLjMxOC04LjM2NC0xOC42ODMtMTguNjgzLTE4LjY4M2MtMTAuMzE4LDAtMTguNjgzLDguMzY1LTE4LjY4MywxOC42ODNoNC4wNjhjMC04LjA3MSw2LjU0My0xNC42MTUsMTQuNjE1LTE0LjYxNWM4LjA3MiwwLDE0LjYxNSw2LjU0MywxNC42MTUsMTQuNjE1SDQzLjkzNXoiPg0KICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZVR5cGU9InhtbCINCiAgICAgIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSINCiAgICAgIHR5cGU9InJvdGF0ZSINCiAgICAgIGZyb209IjAgMjUgMjUiDQogICAgICB0bz0iMzYwIDI1IDI1Ig0KICAgICAgZHVyPSIwLjZzIg0KICAgICAgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiLz4NCiAgICA8L3BhdGg+DQogIDwvc3ZnPg0KPC9kaXY+DQo8L2JvZHk+DQo8L2h0bWw+&quot;); loading.once(&#39;show&#39;, () =&gt; { mainWindow = new BrowserWindow({webPreferences:{nodeIntegration:false}, show:false, width: 800, height: 600, title:&quot;&quot;}) mainWindow.webContents.once(&#39;dom-ready&#39;, () =&gt; { setTimeout( () =&gt; { mainWindow.show() mainWindow.reload() loading.hide() loading.close() }, 7000) }) // long loading html mainWindow.loadURL(&#39;http://127.0.0.1:&#39;+port) // Emitted when the window is closed. mainWindow.on(&#39;closed&#39;, function () { cleanUpApplication() }) }) loading.show() } There are some basic code features you should know. require in javascript is equivalent to loading a library in other languaes. Console.log is the same as printing to terminal and path.join combines multiple strings into a path. Most of this can be figured out from reading the code and few comments. The primary things this code does is: Sets the path to the ui.R file: var appPath = path.join(app.getAppPath(), &quot;R_code&quot;, &quot;ui.R&quot; ) Sets the path to the R compiler: execPath = path.join(app.getAppPath(), &quot;R-Portable-Mac&quot;, &quot;bin&quot;, &quot;R&quot; ) Sets environmental variables: var macAbsolutePath = path.join(app.getAppPath(), &quot;R-Portable-Mac&quot;) var env_path = macAbsolutePath+((process.env.PATH)?&quot;:&quot;+process.env.PATH:&quot;&quot;); var env_libs_site = macAbsolutePath+&quot;/library&quot;+((process.env.R_LIBS_SITE)?&quot;:&quot;+process.env.R_LIBS_SITE:&quot;&quot;); process.env.PATH = env_path process.env.R_LIBS_SITE = env_libs_site process.env.NODE_R_HOME = macAbsolutePath Runs the shiny app: const childProcess = child.spawn(execPath, [&quot;-e&quot;, &quot;shiny::runApp(file.path(&#39;&quot;+appPath+&quot;&#39;), port=&quot;+port+&quot;)&quot;]) Gets the loading graphic: loading.loadURL(&quot;data:text/html;charset=utf-8;base64,PGh0bWw+D...&quot;); Sets the timeout limit: mainWindow.webContents.once(&#39;dom-ready&#39;, () =&gt; { setTimeout( () =&gt; { mainWindow.show() mainWindow.reload() loading.hide() loading.close() }, 7000) Sets the address that the app is run: const port = &quot;9194&quot; mainWindow.loadURL(&#39;http://127.0.0.1:&#39;+port) You may want to alter the timeout limit (currently 7000) if the app is failing to load within the required time. I have also found that occasionally Catalina blocks ports for some unknown reason. You may want to kill the process manually from the terminal and change the port number (currently 9194) before running again. One final issue I previously had was that the version of electron in the npm_modules folder was outdated and throwing an error, causing the app to constantly crash. To fix this I crated a new shny app and transferred the electron module from this across, and then alterred the package.json file to match the newer version. "],
["16-developerOther.html", "3.4 Other Information", " 3.4 Other Information There are a few final points you should be aware of if you are going to be building on this application. Firstly, if you want to add more libraries to the app you must install them to the stand-alone R compiler. To do this, go to the R-Portable-Mac folder in your terminal and then start the compiler using the shortcut, ./R. You can then simply install them as you normally would (install.packages(&quot;package name&quot;)). Next, I have had some serious issues with permissions and Catalina. When I ran npm start I was told that this is not a trusted app etc. I found that the only way to get this to work was to reinstall a local version of npm and then try the command again. Hopefully, this time it will register and throw up different warnings. You will need to follow the standard proceedures for allowing files to be openned using the security section of system preferences. You may also need to reinstall some of the libraries (shiny, tidyverse, httput). This is a really irritating error and I wish I could say I knew a better way to fix it. The section in the energy_spectrum.R file which sets the hovering energy box position is acting strangely. For the following lines: left_px &lt;- hover$range$left + left_pct * (hover$range$right - hover$range$left)/2 - hover$range$left/2 top_px &lt;- hover$range$top + top_pct * (hover$range$bottom - hover$range$top)/2 - hover$range$top/2 I had to recently add the /2 and final arguments (hover$range$left/2 and hover$range$left/2) because the hovering box in the latest compilation changed its behaviour. Be on the lookout for this in future versions, it may need to be reverted. You cannot add Rcpp code as methods. A C compiler is not supplied with the app and it will throw an error. To get around this you will need to create custom packages and link them as a library. I have done this for the dan and SOE functions and these are placed in the libraries folder within R-Portable-Mac. You can easily alter the app’s aesthetics using the skin property at the bottom of the ui.R file. I have found this to be quite restrictive though and instead opted to alter the css, written at the top of the file. The main ones you will likely change if you wanted to reskin it are found at the bottom of the css section and it should be easy to determine what they match up with. Please add any new libraries to the references tab and keep the release notes up to date. If you make significant changes don’t hesitate to add your name to the references section too. Future updates I think would be good: Re-add the MLEM code (it was rediculously slow previously, it needs a lot of work) Add the ability to combine multiple angle X-Z images (may cause memory issues as many files will be loaded) Add HPF for the combined angle image (currently done in python) "]
]
